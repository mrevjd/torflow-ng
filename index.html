<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Map with Particles</title>
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/deck.gl@8.8.24/dist.min.js"></script>
    <script src="https://unpkg.com/@luma.gl/core@8.4.5/dist.min.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        #map { width: 100%; height: 100vh; }
    </style>
</head>
<body>
    <div id="map"></div>

    <script>
        // Initialize the MapLibre map
        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
            center: [0, 0],
            zoom: 2
        });

        // Define initial view state
        const initialViewState = {
            longitude: 0,
            latitude: 0,
            zoom: 2,
            pitch: 0,
            spy: 0,
            bearing: 0
        };

        // Initialize Deck.gl
        const deckGL = new deck.DeckGL({
            initialViewState,
            controller: true,
            layers: [],
            onViewStateChange: ({ viewState }) => {
                map.jumpTo({
                    center: [viewState.longitude, viewState.latitude],
                    zoom: viewState.zoom,
                    bearing: viewState.bearing,
                    pitch: viewState.pitch
                });
            }
        });

        map.on('load', () => {
            const locations = [
                { id: 'A', coordinates: [-74.006, 40.7128] }, // New York
                { id: 'B', coordinates: [2.3522, 48.8566] },  // Paris
                { id: 'C', coordinates: [139.6917, 35.6895] } // Tokyo
            ];

            const connections = [
                { source: 'A', target: 'B', count: 20 },
                { source: 'A', target: 'C', count: 10 },
                { source: 'B', target: 'C', count: 5 }
            ];

            // Mapping locations to IDs for easy lookup
            const locationLookup = locations.reduce((acc, loc) => {
                acc[loc.id] = loc.coordinates;
                return acc;
            }, {});

            // Initialize particles with progress state
            const particles = connections.flatMap(conn => {
                const particleArray = [];
                for (let i = 0; i < conn.count; i++) {
                    particleArray.push({
                        ...conn,
                        sourcePos: locationLookup[conn.source],
                        targetPos: locationLookup[conn.target],
                        progress: Math.random() // Initial random progress for each particle
                    });
                }
                return particleArray;
            });

            // Method to animate particles
            const animateParticles = (particles, { tick }) => {
                particles.forEach(particle => {
                    particle.progress += tick * 0.001; // Adjust this factor for speed
                    if (particle.progress > 1) particle.progress = 0; // Reset progress
                });
            };

            // Create an ArcLayer for connection lines
            const arcLayer = new deck.ArcLayer({
                id: 'arc-layer',
                data: connections,
                getSourcePosition: d => locationLookup[d.source],
                getTargetPosition: d => locationLookup[d.target],
                getSourceColor: [0, 128, 255],
                getTargetColor: [0, 255, 128],
                getWidth: d => Math.sqrt(d.count)
            });

            // Create a ScatterplotLayer for animated particles
            const particleLayer = new deck.ScatterplotLayer({
                id: 'particle-layer',
                data: particles,
                getPosition: d => {
                    // Interpolate position between source and target based on progress
                    const [sx, sy] = d.sourcePos;
                    const [tx, ty] = d.targetPos;
                    const x = sx + d.progress * (tx - sx);
                    const y = sy + d.progress * (ty - sy);
                    return [x, y];
                },
                getFillColor: [255, 0, 0], // Particle color (red)
                getRadius: 5 // Particle radius
            });

            // Function to update particles and create an animation loop
            const animationLoop = new deck.AnimationLoop({
                onInitialize: ({ gl }) => {
                    deckGL.setProps({ gl }); // Use the same WebGL context
                    return { tick: 0 };
                },
                onRender: ({ tick }) => {
                    animateParticles(particles, { tick });
                    // Update Deck.gl layers with animated particles
                    deckGL.setProps({
                        layers: [arcLayer, particleLayer]
                    });
                }
            });

            animationLoop.start();

            console.log('Deck.gl layers created and animation loop started');
        });

        // Synchronization function for MapLibre to Deck.gl
        map.on('move', () => {
            const center = map.getCenter();
            deckGL.setProps({
                viewState: {
                    longitude: center.lng,
                    latitude: center.lat,
                    zoom: map.getZoom(),
                    bearing: map.getBearing(),
                    pitch: map.getPitch()
                }
            });
        });
    </script>
</body>
</html>
